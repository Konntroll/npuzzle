<!DOCTYPE HTML>

<html>
	<head>
		<title>n-Puzzle</title>
		<link rel="stylesheet" type="text/css" href="puzzlestyles.css">
		<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
	</head>
	<body>
		<div id="puzzle">
			<puzzle></puzzle>
		</div>
	</body>
</html>

<script>

Vue.component('tile', {
	props: {
		value: Number,
		index: Number
	},
	data() {
		return {
			empty: false
		}
	},
	template: `
		<div class="tile"
			 v-bind:class="{empty: empty}"
			 v-on:click="move(index)">{{this.value}}</div>
	`,
	methods: {
		emptySocket(val) {
			//this hides the zero tile making it appear empty
			//and communicates its position to the parent
			if (val == 0) {
				this.empty = !this.empty;
				this.$emit('empty-tile', this.index)
			}
		},
		move(trg) {
			//this tells the parent that we are trying
			//to move a tile, triggering a number of checks
			//confirming if the move is valid
			this.$emit('move', trg)
		}
	},
	created() {
		this.emptySocket(this.value);
	}
})

var puzzle = new Vue ({
	el: '#puzzle',
	data: {
		tiles: [],
		solved: [],
		zeroIndex: 0,
		counter: 0,
		moveKey: 0,
		boardScale: 4,
		isInProgress: true
	},
	template: `
		<div>
			<div id="nav-bar">
				<img src="8.png" v-on:click="resize(3)" />
				<img src="15.png" v-on:click="resize(4)" />
				<div id="counter">{{counter}}</div>
			</div>
			<div id="puzzle-box" 
				 v-bind:key="moveKey"
				 v-if="isInProgress">
				<template v-for="(tile, index) in tiles">
					<tile v-bind:value="tile"
						  v-bind:index="index"
						  v-on:move="move"
						  v-on:empty-tile="setZero"></tile>
				</template>
			</div>
			<div id="gameOver"
				 v-if="!isInProgress">
				<h1>Game Over</h1>
				<h3>Congratulations, you solved the puzzle in {{ counter }} moves.</h3>
				<h3>Would you like to have another go?</h3>
				<button id="repeat" v-on:click="resize(boardScale)">Play again</button>
			</div>
		</div>
	`,
	methods: {
		setBoard() {
			//this toggles isInProgress to true so that the
			//board is displayed and not the game over text
			this.isInProgress = true;
			
			//these variables are used to create a seed array
			var tileEnum = 0;
			var holder = [];
			
			//which is populated in ascending order by this loop
			while (holder.length < this.boardScale * this.boardScale) {
				holder.push(tileEnum);
				tileEnum++;
			}
			
			//since this is almost the same as the end
			//state of the puzzle, we clone this array
			this.solved = holder.slice();
			
			//and move the zero from index 0, to index 15
			//creating an array to compare our progress against
			this.solved.push(this.solved.shift());
			
			//we then shuffle the array to set up the puzzle
			var range = holder.length;
			var pointer;
			while (this.tiles.length < this.boardScale * this.boardScale) {
				pointer = Math.floor(Math.random() * range);
				this.tiles.push(holder[pointer]);
				holder.splice(pointer, 1);
				range--;
			}
			
			//and make sure the combination we got 
			//can actually be solved
			this.validate();
		},
		validate() {
			
			//this function checks if the board
			//generated by setBoard() can be solved;
			//if the board has no solutions, validate()
			//wipes the board and calls setBoard() again
			//doing so until a solvable board is produced
			
			//the following block of code counts
			//the number of instances where the value
			//of a given tile is higher than the value
			//of each tile following it, except for zero
			var inversions = 0;
			for (var i = 0; i < this.tiles.length; i++) {
				for (var y = i; y < this.tiles.length; y++) {
					if (this.tiles[i] > this.tiles[y] && this.tiles[y] != 0) {
						inversions++;
					}
				}
			}
			
			//because rules for validation of boards
			//of different scale differ in complexity
			//the following two-pronged 'if' is used
			if (this.boardScale == 3) {
				
				//validation for scale 3 boards is simple
				//and only requires that the number of
				//inversions as defined above be even
				
				if (inversions % 2 == 1) {
					this.tiles = [];
					this.setBoard();
				}
			} else {
				
				//for scale 4 boards we also need to know
				//where the empty tile is positioned
				
				var zeroPosition = this.tiles.indexOf(0);
				if (zeroPosition < 4 || (zeroPosition > 7 && zeroPosition < 12)) {
					zeroPosition = "even";
				} else {
					zeroPosition = "odd";
				}
				if (inversions % 2 == 0 && zeroPosition == 'even' ||
					inversions % 2 == 1 && zeroPosition == 'odd') {
					this.tiles = [];
					this.setBoard();
				}
			}
		},
		setZero(val) {
			
			//this keeps track of the index of the empty tile
			//in the tiles array, which we need to know
			//to be able to determine, which tiles can
			//be moved into it
			
			this.zeroIndex = val;
		},
		move(id) {
			
			//whenever a tile is clicked, we check to see
			//if it is adjacent to the empty tile and
			//can be moved into it
			
			var adjacencyCheck = this.isAdjacent();
			
			//if the tile is adjacent, we register the
			//click, exchange the values between respective
			//indices in the array, redraw the board by
			//incrementing the key bound to it and check
			//to see if the puzzle is solved
			
			if (adjacencyCheck.includes(id)) {
				this.counter++;
				this.tiles[this.zeroIndex] = this.tiles[id];
				this.tiles[id] = 0;
				this.moveKey++;
				this.check();
			}
		},
		isAdjacent() {
			
			//this where the check for adjancency happens;
			
			//first we create and array to hold the indices
			//of tiles adjacent to the empty one
			var adjacent = [];
			
			//we then check that the tiles to the left and right
			//of the empty one are in the same row with it;
			//if they are not, we add null to the array instead
			//of storing their index, which would cause wrong behaviour
			
			//this is to check if the tile to the left is on the row above
			if (this.zeroIndex % this.boardScale == 0) {
				adjacent.push(null);
			} else {
				adjacent.push(this.zeroIndex - 1);
			}
			
			//this is to check if the tile to the right is on the row below
			if ((this.zeroIndex + 1) % this.boardScale == 0) {
				adjacent.push(null);
			} else {
				adjacent.push(this.zeroIndex + 1);
			}
			
			//the following two statements do the same for
			//tiles directly above and below the empty one;
			//since these can either be there or not, we can
			//store either their index or 'undefined' as both
			//will satisfy the conditions of our adjacency test
			adjacent.push(this.zeroIndex - this.boardScale);
			adjacent.push(this.zeroIndex + this.boardScale);
			
			return adjacent;
		},
		check() {
		
			//this function checks if we have solved
			//the puzzle by comparing each position in
			//the tiles array to each corresponding item
			//in the solved and returning if the two differ
		
			for (var i = 0; i < this.tiles.length; i++) {
				if (this.tiles[i] !== this.solved[i]) {
					return;
				}
			}
			
			//if value in both arrays align, the puzzle is solved
			setTimeout(this.gameOver.bind(this), 1000);
		},
		gameOver() {
			//and we display Game Over text in place of the board
			this.isInProgress = false;
		},
		resize(scale) {
			
			//this function toggles the scale of the puzzle
			//reseting base values and updating a CSS root
			//variable for correct display of the grid/board
			//before calling setBoard() to create a new board
			
			this.boardScale = scale;
			this.tiles = [];
			this.counter = 0;
			document.documentElement.style.setProperty("--colNum", this.boardScale);
			this.moveKey++;
			this.setBoard();
		}
	},
	created() {
		//this generates the puzzle board on page load
		this.setBoard();
	}
})

</script>